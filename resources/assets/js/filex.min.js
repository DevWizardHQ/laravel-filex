(function (window,document) {"use strict";function showErrorMessage(message,componentId = null,timeout = 5000) {showNotification(message,'error',componentId,timeout);} function showSuccessMessage(message,componentId = null,timeout = 3000) {showNotification(message,'success',componentId,timeout);} function showWarningMessage(message,componentId = null,timeout = 4000) {showNotification(message,'warning',componentId,timeout);} function showInfoMessage(message,componentId = null,timeout = 3000) {showNotification(message,'info',componentId,timeout);} function showNotification(message,type = 'info',componentId = null,timeout = 3000) {let container = document.getElementById('filex-notifications-container');if (!container) {container = document.createElement('div');container.id = 'filex-notifications-container';container.className = 'filex-notifications-container';document.body.appendChild(container);} const notification = document.createElement('div');notification.className = `filex-notification filex-notification--${type}`;const icon = getNotificationIcon(type);notification.innerHTML = ` <div class="filex-notification__content"> <div class="filex-notification__icon">${icon}</div> <div class="filex-notification__message">${message}</div> <button class="filex-notification__close" type="button" aria-label="Close notification">Ã—</button> </div> ${timeout > 0 ? '<div class="filex-notification__progress"></div>' : ''} `;const closeBtn = notification.querySelector('.filex-notification__close');closeBtn.addEventListener('click',() => removeNotification(notification));container.appendChild(notification);if (timeout > 0) {const progressBar = notification.querySelector('.filex-notification__progress');if (progressBar) {progressBar.style.width = '100%';progressBar.style.transition = `width ${timeout}ms linear`;setTimeout(() => {progressBar.style.width = '0%';},10);} setTimeout(() => {if (notification.parentNode) {removeNotification(notification);}},timeout);} if (componentId && type === 'error') {updateComponentStatus(componentId,message);} return notification;} function removeNotification(notification) {if (!notification || !notification.parentNode) return;notification.classList.add('filex-notification--sliding-out');setTimeout(() => {if (notification.parentNode) {notification.remove();}},300);} function getNotificationIcon(type) {const icons = {error: `<svg xmlns="http: <circle cx="12" cy="12" r="10"/> <path fill="white" d="M12 8v4M12 16h.01" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/> </svg>`,success: `<svg xmlns="http: <circle cx="12" cy="12" r="10"/> <path fill="white" d="M9 12l2 2 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/> </svg>`,warning: `<svg xmlns="http: <path d="M12 2L1 21h22L12 2zm0 3.5L19.5 19h-15L12 5.5zM11 10v4h2v-4h-2zm0 6v2h2v-2h-2z"/> </svg>`,info: `<svg xmlns="http: <circle cx="12" cy="12" r="10"/> <path fill="white" d="M12 8v8M12 16h.01" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/> </svg>`};return icons[type] || icons.info;} function updateComponentStatus(componentId,message) {const statusElement = document.getElementById(componentId + '-status');if (statusElement) {const errorText = statusElement.querySelector('.error-text');const errorMessage = statusElement.querySelector('.error-message');if (errorText && errorMessage) {errorText.style.display = 'inline';errorMessage.textContent = message;statusElement.style.display = 'block';}}} function makeAjaxRequest(url,options = {}) {const defaultOptions = {method: 'GET',headers: {'Content-Type': 'application/json','X-CSRF-TOKEN': getCSRFToken(),'X-Requested-With': 'XMLHttpRequest'},timeout: 30000};const finalOptions = {...defaultOptions,...options};const controller = new AbortController();const timeoutId = setTimeout(() => controller.abort(),finalOptions.timeout);finalOptions.signal = controller.signal;return fetch(url,finalOptions) .then(response => {clearTimeout(timeoutId);const contentType = response.headers.get('content-type');if (!response.ok) {if (contentType && contentType.includes('application/json')) {return response.json().then(data => {throw new Error(data.message || data.error || `Server error: ${response.status}`);});} else {throw new Error(`HTTP ${response.status}: ${response.statusText}`);}} if (contentType && contentType.includes('application/json')) {return response.json();} else {return response.text();}}) .catch(error => {clearTimeout(timeoutId);if (error.name === 'AbortError') {throw new Error('Request timed out. Please try again.');} else if (error.message) {throw error;} else {throw new Error('Network error. Please check your connection and try again.');}});} function initializeFilex() {if (window.filexInitialized) {return;} window.filexInitialized = true;if (typeof Dropzone === "undefined") {console.error("Dropzone.js library not loaded");return;} Dropzone.autoDiscover = false;const filexElements = document.querySelectorAll( ".filex-uploader[data-component-id]" );if (filexElements.length === 0) {return;} filexElements.forEach(function (filexElement) {const componentId = filexElement.dataset.componentId;if ( filexElement.getAttribute("data-filex-initialized") === "true" || filexElement.dropzone ) {return;} const hiddenInputsContainer = document.getElementById( componentId + "-hidden-inputs" );const statusElement = document.getElementById( componentId + "-status" );if (!filexElement) {console.error("Filex element not found:",componentId);return;} const parentForm = filexElement.closest("form");const submitButtons = parentForm ? parentForm.querySelectorAll( 'button[type="submit"],input[type="submit"]' ) : [];let activeUploads = 0;let uploadedFiles = [];let failedFiles = [];let retryCount = {};const rawConfig = filexElement.dataset.config;let config = {};if (rawConfig) {try {config = JSON.parse(rawConfig);} catch (e) {console.warn( "Failed to parse Filex config,using defaults:",e );}} config = {componentId: config.componentId || filexElement.dataset.componentId,name: config.name || filexElement.dataset.name || "files",multiple: config.multiple !== undefined ? config.multiple : filexElement.dataset.multiple === "true",required: config.required !== undefined ? config.required : filexElement.hasAttribute("data-required"),disabled: config.disabled !== undefined ? config.disabled : filexElement.hasAttribute("data-disabled"),readonly: config.readonly !== undefined ? config.readonly : filexElement.hasAttribute("data-readonly"),maxFiles: config.maxFiles || (filexElement.dataset.maxFiles ? parseInt(filexElement.dataset.maxFiles) : null),maxSize: config.maxSize || parseFloat(filexElement.dataset.maxFilesize) || 10,minSize: config.minSize || null,accept: config.accept || filexElement.dataset.acceptedFiles || null,autoProcess: config.autoProcess !== undefined ? config.autoProcess : true,parallelUploads: config.parallelUploads || 2,chunkSize: config.chunkSize || 1048576,retries: config.retries || 3,timeout: config.timeout || 30000,validation: config.validation || {rules: JSON.parse( filexElement.dataset.frontendRules || "[]" ),enabled: filexElement.dataset.validationEnabled === "true",},messages: config.messages || {},debug: config.debug || false,thumbnailWidth: config.thumbnailWidth || 120,thumbnailHeight: config.thumbnailHeight || 120,thumbnailMethod: config.thumbnailMethod || "contain",events: config.events || {},};const existingInputs = hiddenInputsContainer ? hiddenInputsContainer.querySelectorAll(".existing-file-input") : [];const existingFilesFromInputs = Array.from(existingInputs).map( (input) => input.value );const existingFilesFromConfig = config.existingFiles || [];const existingFiles = [ ...existingFilesFromInputs,...existingFilesFromConfig,].filter(Boolean);if (existingFiles && existingFiles.length > 0) {uploadedFiles = [...new Set(existingFiles)];} const hiddenInputName = config.multiple ? config.name + "[]" : config.name;const dropzoneConfig = {url: window.filexRoutes ? window.filexRoutes.upload : "/filex/upload/temp",method: "POST",headers: {"X-CSRF-TOKEN": getCSRFToken(),},paramName: "file",maxFilesize: 999999,maxFiles: config.maxFiles,acceptedFiles: config.accept,addRemoveLinks: true,autoProcessQueue: config.autoProcess,parallelUploads: config.parallelUploads,uploadMultiple: false,chunking: true,chunkSize: config.chunkSize,parallelChunkUploads: false,retryChunks: true,retryChunksLimit: config.retries,forceChunking: function (file) {return file.size > 50 * 1024 * 1024;},retries: config.retries,timeout: config.timeout,thumbnailWidth: config.thumbnailWidth,thumbnailHeight: config.thumbnailHeight,thumbnailMethod: config.thumbnailMethod,dictRemoveFile: config.messages.dictRemoveFile || "",dictDefaultMessage: config.messages.dictDefaultMessage || "Drop files here or click to upload",dictFileTooBig: (config.messages.dictFileTooBig || "File is too big (:filesize MB). Max filesize: :maxFilesize MB.") .replace(':maxFilesize',config.maxSize) .replace(':maxfilesize',config.maxSize),dictInvalidFileType: config.messages.dictInvalidFileType || "You cannot upload files of this type.",dictResponseError: config.messages.dictResponseError || "Server error occurred during upload. Please try again.",dictMaxFilesExceeded: config.messages.dictMaxFilesExceeded || "You cannot upload any more files.",accept: function (file,done) {done();},init: function () {const dz = this;async function validateFile(file) {const errors = [];if (!config.validation.enabled) {return errors;} if ( config.validation.rules && config.validation.rules.length > 0 ) {for (const rule of config.validation.rules) {const ruleError = await applyValidationRule( file,rule );if (ruleError) {errors.push(ruleError);}}} if (file.size > config.maxSize * 1024 * 1024) {const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);const message = (config.messages.dictFileTooBig || "File is too big (:filesize MB). Max filesize: :maxFilesize MB.") .replace(':filesize',fileSizeMB) .replace(':maxFilesize',config.maxSize) .replace(':maxfilesize',config.maxSize);errors.push(message);} if ( config.minSize && file.size < config.minSize * 1024 * 1024 ) {errors.push( `File is too small. Minimum size: ${config.minSize}MB` );} if (config.accept) {const acceptedTypes = config.accept .split(",") .map((type) => type.trim());let isValidType = false;for (const acceptedType of acceptedTypes) {if (acceptedType.includes("*")) {const pattern = acceptedType.replace( "*","" );if ( file.type && file.type.startsWith(pattern) ) {isValidType = true;break;}} else if (acceptedType.startsWith(".")) {const fileExtension = "." + file.name .split(".") .pop() .toLowerCase();if ( fileExtension === acceptedType.toLowerCase() ) {isValidType = true;break;}} else if (file.type === acceptedType) {isValidType = true;break;}} if (!isValidType) {errors.push("File type not allowed");}} return errors;} async function applyValidationRule(file,rule) {if (typeof rule !== "string") return null;const [ruleName,ruleValue] = rule.includes(":") ? rule.split(":",2) : [rule,null];switch (ruleName) {case "required": return null;case "image": if (!file.type.startsWith("image/")) {return "File must be an image";} return null;case "mimes": if (ruleValue) {const allowedMimes = ruleValue .split(",") .map((ext) => ext.trim());const fileExt = getFileExtension(file.name);if (!allowedMimes.includes(fileExt)) {return `File type not allowed. Allowed types: ${allowedMimes.join( "," )}`;}} return null;case "max": if (ruleValue) {const maxSizeKB = parseInt(ruleValue);if (file.size > maxSizeKB * 1024) {const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);const maxSizeMB = (maxSizeKB / 1024).toFixed(2);const message = (config.messages.dictFileTooBig || "File is too big (:filesize MB). Max filesize: :maxFilesize MB.") .replace(':filesize',fileSizeMB) .replace(':maxFilesize',maxSizeMB) .replace(':maxfilesize',maxSizeMB);return message;}} return null;case "min": if (ruleValue) {const minSizeKB = parseInt(ruleValue);if (file.size < minSizeKB * 1024) {return `File too small. Minimum size: ${formatFileSize( minSizeKB * 1024 )}`;}} return null;case "size": if (ruleValue) {const exactSizeKB = parseInt(ruleValue);if (file.size !== exactSizeKB * 1024) {return `File must be exactly ${formatFileSize( exactSizeKB * 1024 )}`;}} return null;case "dimensions": if ( file.type.startsWith("image/") && ruleValue ) {return await validateImageDimensions( file,ruleValue );} return null;case "file": return null;case "mimetypes": if (ruleValue) {const allowedMimeTypes = ruleValue .split(",") .map((type) => type.trim());if (!allowedMimeTypes.includes(file.type)) {return `File MIME type not allowed. Allowed types: ${allowedMimeTypes.join( "," )}`;}} return null;case "between": if (ruleValue) {const [minSize,maxSize] = ruleValue .split(",") .map((size) => parseInt(size.trim()));const fileSizeKB = Math.round( file.size / 1024 );if ( fileSizeKB < minSize || fileSizeKB > maxSize ) {return `File size must be between ${formatFileSize( minSize * 1024 )} and ${formatFileSize( maxSize * 1024 )}`;}} return null;default: if (config.debug) {console.warn( "Unknown validation rule:",ruleName );} return null;}} function validateImageDimensions(file,dimensionRule) {return new Promise((resolve) => {const img = new Image();const url = URL.createObjectURL(file);img.onload = function () {URL.revokeObjectURL(url);const dimensions = parseDimensionRule(dimensionRule);const errors = [];if ( dimensions.min_width && img.width < dimensions.min_width ) {errors.push( `Image width too small. Minimum: ${dimensions.min_width}px` );} if ( dimensions.max_width && img.width > dimensions.max_width ) {errors.push( `Image width too large. Maximum: ${dimensions.max_width}px` );} if ( dimensions.min_height && img.height < dimensions.min_height ) {errors.push( `Image height too small. Minimum: ${dimensions.min_height}px` );} if ( dimensions.max_height && img.height > dimensions.max_height ) {errors.push( `Image height too large. Maximum: ${dimensions.max_height}px` );} if ( dimensions.width && img.width !== dimensions.width ) {errors.push( `Image width must be exactly ${dimensions.width}px` );} if ( dimensions.height && img.height !== dimensions.height ) {errors.push( `Image height must be exactly ${dimensions.height}px` );} if (dimensions.ratio) {const actualRatio = img.width / img.height;if ( Math.abs( actualRatio - dimensions.ratio ) > 0.01 ) {errors.push( `Image aspect ratio must be ${dimensions.ratio}` );}} resolve(errors.join(";") || null);};img.onerror = function () {URL.revokeObjectURL(url);resolve("Invalid image file");};img.src = url;});} function parseDimensionRule(dimensionRule) {const dimensions = {};const parts = dimensionRule.split(",");for (const part of parts) {const [key,value] = part.split("=");if (key && value) {dimensions[key.trim()] = parseFloat( value.trim() );}} return dimensions;} function getFileExtension(filename) {return filename.toLowerCase().split(".").pop();} function formatFileSize(bytes) {if (bytes >= 1048576) {return ( Math.round((bytes / 1048576) * 100) / 100 + " MB" );} else if (bytes >= 1024) {return ( Math.round((bytes / 1024) * 100) / 100 + " KB" );} return bytes + " bytes";} function getEstimatedFileSize(extension) {const sizeEstimates = {jpg: 500000,jpeg: 500000,png: 800000,gif: 300000,bmp: 2000000,webp: 400000,svg: 50000,pdf: 1000000,doc: 500000,docx: 500000,txt: 10000,rtf: 100000,mp4: 5000000,avi: 8000000,mov: 6000000,wmv: 4000000,flv: 3000000,webm: 4000000,mp3: 3000000,wav: 10000000,ogg: 2500000,aac: 2000000,flac: 8000000,zip: 2000000,rar: 2000000,"7z": 1500000,tar: 2500000,default: 100000,};return ( sizeEstimates[extension] || sizeEstimates["default"] );} dz.on("init",function () {if (!existingFiles || existingFiles.length === 0) {return;} existingFiles.forEach(function (filePath,index) {const fileName = filePath.split("/").pop();const extension = fileName .split(".") .pop() .toLowerCase();let fileType = "";const imageExtensions = [ "jpg","jpeg","png","gif","bmp","webp","svg",];const documentExtensions = [ "pdf","doc","docx","txt","rtf",];const videoExtensions = [ "mp4","avi","mov","wmv","flv","webm",];const audioExtensions = [ "mp3","wav","ogg","aac","flac",];if (imageExtensions.includes(extension)) {fileType = "image/" + (extension === "jpg" ? "jpeg" : extension);} else if (documentExtensions.includes(extension)) {fileType = "application/" + extension;} else if (videoExtensions.includes(extension)) {fileType = "video/" + extension;} else if (audioExtensions.includes(extension)) {fileType = "audio/" + extension;} else {fileType = "application/octet-stream";} const mockFile = {name: fileName,size: getEstimatedFileSize(extension),type: fileType,accepted: true,processing: false,upload: {progress: 100,},status: Dropzone.SUCCESS,tempPath: filePath,isExisting: true,};if ( window.filexRoutes && window.filexRoutes.fileInfo ) {const fileInfoUrl = window.filexRoutes.fileInfo.replace( "__FILEPATH__",encodeURIComponent(filePath) );makeAjaxRequest(fileInfoUrl,{method: 'GET'}) .then((data) => {if (data.success && data.size) {mockFile.size = data.size;if (mockFile.previewElement) {const sizeElement = mockFile.previewElement.querySelector( ".dz-size span" );if (sizeElement) {sizeElement.textContent = formatFileSize( data.size );}}}}) .catch((error) => {console.warn('Failed to fetch file info for existing file:',error.message);mockFile.size = getEstimatedFileSize(extension);if (mockFile.previewElement) {const sizeElement = mockFile.previewElement.querySelector( ".dz-size span" );if (sizeElement) {sizeElement.textContent = formatFileSize( mockFile.size );}}});} else {mockFile.size = getEstimatedFileSize(extension);} dz.emit("addedfile",mockFile);dz.emit("complete",mockFile);setTimeout(function () {if (mockFile.previewElement) {const imageElement = mockFile.previewElement.querySelector( ".dz-image" );if (imageElement) {const iconSvg = getFileIconSvg(extension);imageElement.innerHTML = iconSvg;} const progressElement = mockFile.previewElement.querySelector( ".dz-progress" );if (progressElement) {progressElement.style.display = "none";} mockFile.previewElement.classList.remove( "dz-error","dz-processing" );mockFile.previewElement.classList.add( "dz-success","filex-preview-existing" );const errorElement = mockFile.previewElement.querySelector( ".dz-error-message" );if (errorElement) {errorElement.style.display = "none";} const successMark = mockFile.previewElement.querySelector( ".dz-success-mark" );if (successMark) {successMark.style.display = "flex";successMark.style.visibility = "visible";successMark.style.opacity = "1";} const errorMark = mockFile.previewElement.querySelector( ".dz-error-mark" );if (errorMark) {errorMark.style.display = "none";errorMark.style.visibility = "hidden";errorMark.style.opacity = "0";}} else {}},300);const removeButton = mockFile.previewElement ? mockFile.previewElement.querySelector( ".dz-remove" ) : null;if (removeButton) {removeButton.addEventListener( "click",function (e) {e.preventDefault();e.stopPropagation();dz.removeFile(mockFile);} );}});});dz.on("addedfile",async function (file) {if (file.previewElement && !file.isExisting) {file.previewElement.classList.add( "filex-preview-new" );const successMark = document.createElement("div");successMark.className = "dz-success-mark";successMark.innerHTML = '<svg xmlns="http: successMark.style.display = "none";successMark.style.visibility = "hidden";file.previewElement.appendChild(successMark);const errorMark = document.createElement("div");errorMark.className = "dz-error-mark";errorMark.innerHTML = '<svg xmlns="http: errorMark.style.display = "none";errorMark.style.visibility = "hidden";file.previewElement.appendChild(errorMark);} if (!file.isExisting) {const validationErrors = await validateFile(file);if ( validationErrors && validationErrors.length > 0 ) {if (config.showErrorNotifications !== false) {showErrorMessage(`Validation failed for ${file.name}: ${validationErrors.join(',')}`,componentId,config.errorTimeout);} if (file.previewElement) {file.previewElement.classList.add( "dz-error" );const errorElement = file.previewElement.querySelector( ".dz-error-message" );if (errorElement) {errorElement.textContent = validationErrors.join(",");errorElement.style.display = 'block';} const errorMark = file.previewElement.querySelector( ".dz-error-mark" );const successMark = file.previewElement.querySelector( ".dz-success-mark" );if (errorMark) {errorMark.style.display = "flex";errorMark.style.visibility = "visible";errorMark.style.opacity = "1";} if (successMark) {successMark.style.display = "none";successMark.style.visibility = "hidden";successMark.style.opacity = "0";}} if (!failedFiles.find((f) => f.name === file.name)) {failedFiles.push({name: file.name,error: validationErrors.join(','),file: file,type: 'validation'});} dz.removeFile(file);updateStatus();return;} else {if (file.previewElement) {file.previewElement.classList.remove("dz-error");const errorElement = file.previewElement.querySelector(".dz-error-message");if (errorElement) {errorElement.style.display = 'none';errorElement.textContent = '';} const errorMark = file.previewElement.querySelector(".dz-error-mark");if (errorMark) {errorMark.style.display = "none";errorMark.style.visibility = "hidden";errorMark.style.opacity = "0";}}}} if ( file.status !== Dropzone.SUCCESS && !file.isExisting ) {activeUploads++;updateFormState();updateStatus();} if (!file.type || !file.type.startsWith("image/")) {const extension = file.name .split(".") .pop() .toLowerCase();const iconSvg = getFileIconSvg(extension);const imageElement = file.previewElement ? file.previewElement.querySelector(".dz-image") : null;if (imageElement) {imageElement.innerHTML = iconSvg;}} if (file.previewElement) {const retryButton = document.createElement("button");retryButton.type = "button";retryButton.className = "dz-retry";retryButton.style.display = "none";retryButton.title = "Retry upload";retryButton.innerHTML = '<svg xmlns="http: retryButton.addEventListener("click",function (e) {e.preventDefault();e.stopPropagation();retryUpload(file);});file.previewElement.appendChild(retryButton);}});dz.on("success",function (file,response) {if (response && response.success && response.tempPath) {file.tempPath = response.tempPath;file.originalName = response.originalName;file.serverSize = response.size;if (config.showSuccessMessages) {showSuccessMessage(`${file.name} uploaded successfully`,componentId,config.successTimeout);} file.status = Dropzone.SUCCESS;if (file.previewElement) {const preview = file.previewElement;const progressEl = preview.querySelector(".dz-progress");const errorEl = preview.querySelector(".dz-error-message");const retryBtn = preview.querySelector(".dz-retry");const successMark = preview.querySelector(".dz-success-mark");const errorMark = preview.querySelector(".dz-error-mark");preview.classList.remove( "dz-processing","dz-error" );preview.classList.add("dz-success");setTimeout(() => {if ( preview && file.status === Dropzone.SUCCESS ) {preview.classList.remove( "dz-processing","dz-error" );preview.classList.add("dz-success");}},100);if (progressEl) {progressEl.style.display = "none";} if (errorEl) {errorEl.style.display = "none";errorEl.textContent = "";} if (retryBtn) {retryBtn.style.display = "none";} if (successMark) {successMark.style.display = "flex";successMark.style.visibility = "visible";successMark.style.opacity = "1";} if (errorMark) {errorMark.style.display = "none";errorMark.style.visibility = "hidden";errorMark.style.opacity = "0";}} if (!uploadedFiles.includes(response.tempPath)) {uploadedFiles.push(response.tempPath);} updateHiddenInputs();const failedIndex = failedFiles.findIndex( (f) => f.name === file.name );if (failedIndex > -1) {failedFiles.splice(failedIndex,1);} delete retryCount[file.name];} else {if (file.previewElement) {file.previewElement.classList.add("dz-error");const errorMsg = response && response.message ? response.message : "Upload failed";const errorElement = file.previewElement.querySelector( ".dz-error-message" );if (errorElement) {errorElement.textContent = errorMsg;}}} activeUploads--;updateFormState();updateStatus();});dz.on("error",function (file,errorMessage,xhr) {activeUploads--;let finalErrorMessage = errorMessage;if (typeof errorMessage === 'object') {if (errorMessage.message) {finalErrorMessage = errorMessage.message;} else if (errorMessage.error) {finalErrorMessage = errorMessage.error;} else {finalErrorMessage = 'Upload failed';}} else if (typeof errorMessage === 'string') {try {const parsed = JSON.parse(errorMessage);finalErrorMessage = parsed.message || parsed.error || errorMessage;} catch (e) {finalErrorMessage = errorMessage;}} if (typeof finalErrorMessage === 'string' && finalErrorMessage.includes(':statusCode')) {if (xhr && xhr.status) {finalErrorMessage = finalErrorMessage.replace(':statusCode',xhr.status);} else {finalErrorMessage = 'Server error occurred during upload';}} if (xhr && xhr.status) {switch (xhr.status) {case 413: finalErrorMessage = 'File is too large for upload';break;case 422: finalErrorMessage = finalErrorMessage.includes('Server responded with') ? 'File validation failed' : finalErrorMessage;break;case 429: finalErrorMessage = 'Too many upload attempts. Please wait and try again.';break;case 500: finalErrorMessage = 'Server error during upload. Please try again.';break;case 0: finalErrorMessage = 'Network error. Please check your connection.';break;default: if (finalErrorMessage.includes('Server responded with') && finalErrorMessage.includes('code')) {finalErrorMessage = `Server error (${xhr.status}): Please try again`;} break;}} else if (finalErrorMessage.includes(':statusCode')) {finalErrorMessage = 'Server error occurred during upload';} const isValidationError = finalErrorMessage.includes('File is too big') || finalErrorMessage.includes('File too large') || finalErrorMessage.includes('File type not allowed') || finalErrorMessage.includes('validation failed');if (config.showErrorNotifications !== false && !isValidationError) {showErrorMessage(`Upload failed for ${file.name}: ${finalErrorMessage}`,componentId,config.errorTimeout);} if (!failedFiles.find((f) => f.name === file.name)) {failedFiles.push({name: file.name,error: finalErrorMessage,file: file,});} if (file.previewElement) {const preview = file.previewElement;const retryBtn = preview.querySelector(".dz-retry");const errorMark = preview.querySelector(".dz-error-mark");const successMark = preview.querySelector(".dz-success-mark");const errorElement = preview.querySelector(".dz-error-message");preview.classList.remove( "dz-success","dz-processing" );preview.classList.add("dz-error");if (errorElement) {errorElement.textContent = finalErrorMessage;errorElement.style.display = 'block';} if (retryBtn) {retryBtn.style.display = "flex";} if (errorMark) {errorMark.style.display = "flex";errorMark.style.visibility = "visible";errorMark.style.opacity = "1";} if (successMark) {successMark.style.display = "none";successMark.style.visibility = "hidden";successMark.style.opacity = "0";}} updateFormState();updateStatus();});dz.on("complete",function (file) {if (file.previewElement) {if (file.status === Dropzone.SUCCESS) {file.previewElement.classList.remove( "dz-processing","dz-error" );file.previewElement.classList.add("dz-success");} else if (file.status === Dropzone.ERROR) {file.previewElement.classList.remove( "dz-processing","dz-success" );file.previewElement.classList.add("dz-error");}}});dz.on("removedfile",function (file) {if (file.tempPath) {const index = uploadedFiles.indexOf(file.tempPath);if (index > -1) {uploadedFiles.splice(index,1);} if ( !file.isExisting && window.filexRoutes && window.filexRoutes.delete ) {const filename = file.tempPath.split("/").pop();const deleteUrl = window.filexRoutes.delete.replace( "__FILENAME__",encodeURIComponent(filename) );makeAjaxRequest(deleteUrl,{method: "DELETE"}) .then(response => {if (response.success) {if (config.debug || config.showSuccessMessages) {showSuccessMessage(`File ${file.name} deleted successfully`,componentId,config.successTimeout);}} else {if (config.showErrorNotifications !== false) {showErrorMessage(response.message || 'Failed to delete file from server',componentId,config.errorTimeout);}}}) .catch(error => {console.error("Failed to delete temp file:",error);if (config.showErrorNotifications !== false) {showErrorMessage(`Failed to delete ${file.name}: ${error.message}`,componentId,config.errorTimeout);}});}} const failedIndex = failedFiles.findIndex( (f) => f.name === file.name );if (failedIndex > -1) {failedFiles.splice(failedIndex,1);} updateHiddenInputs();updateStatus();});dz.on("maxfilesexceeded",function (file) {const maxFiles = config.maxFiles || 'unlimited';if (config.showErrorNotifications !== false) {showErrorMessage(`Maximum number of files exceeded. Limit: ${maxFiles}`,componentId,config.errorTimeout);} dz.removeFile(file);});},};if (filexElement.dropzone) {return;} filexElement.setAttribute("data-filex-initialized","true");const myFilex = new Dropzone(filexElement,dropzoneConfig);if (existingFiles && existingFiles.length > 0) {setTimeout(function () {processExistingFiles(myFilex,existingFiles);},100);} function processExistingFiles(dz,fileList) {fileList.forEach(function (filePath,index) {const fileName = filePath.split("/").pop();const extension = fileName.split(".").pop().toLowerCase();let fileType = "";const imageExtensions = [ "jpg","jpeg","png","gif","bmp","webp","svg",];if (imageExtensions.includes(extension)) {fileType = "image/" + (extension === "jpg" ? "jpeg" : extension);} else {fileType = "application/octet-stream";} const mockFile = {name: fileName,size: 500000,type: fileType,accepted: true,processing: false,upload: {progress: 100},status: Dropzone.SUCCESS,tempPath: filePath,isExisting: true,};dz.emit("addedfile",mockFile);dz.emit("complete",mockFile);setTimeout(function () {if (mockFile.previewElement) {const imageElement = mockFile.previewElement.querySelector( ".dz-image" );if (imageElement) {const extension = fileName .split(".") .pop() .toLowerCase();const iconSvg = getFileIconSvg(extension);imageElement.innerHTML = iconSvg;} mockFile.previewElement.classList.remove( "dz-error","dz-processing" );mockFile.previewElement.classList.add( "dz-success","filex-preview-existing" );const progressElement = mockFile.previewElement.querySelector( ".dz-progress" );if (progressElement) {progressElement.style.display = "none";}}},200);});} filexElement.addEventListener("click",function (e) {if ( e.target.matches(".dz-remove") || e.target.closest(".dz-remove") ) {e.preventDefault();e.stopPropagation();const removeButton = e.target.matches(".dz-remove") ? e.target : e.target.closest(".dz-remove");const preview = removeButton.closest(".dz-preview");if (preview && preview._file) {myFilex.removeFile(preview._file);}} if ( e.target.matches(".dz-retry") || e.target.closest(".dz-retry") ) {e.preventDefault();e.stopPropagation();const retryButton = e.target.matches(".dz-retry") ? e.target : e.target.closest(".dz-retry");const preview = retryButton.closest(".dz-preview");if (preview && preview._file) {retryUpload(preview._file);}}});window[componentId] = myFilex;function retryUpload(file) {const currentRetries = retryCount[file.name] || 0;if (currentRetries >= 3) {if (config.showErrorNotifications !== false) {showErrorMessage(`Maximum retry attempts reached for ${file.name}`,componentId,config.errorTimeout);} return;} retryCount[file.name] = currentRetries + 1;const retryButton = file.previewElement ? file.previewElement.querySelector(".dz-retry") : null;if (retryButton) {retryButton.style.display = "none";} file.status = Dropzone.QUEUED;if (file.previewElement) {file.previewElement.classList.remove("dz-error");} const failedIndex = failedFiles.findIndex( (f) => f.name === file.name );if (failedIndex > -1) {failedFiles.splice(failedIndex,1);} activeUploads++;updateFormState();updateStatus();myFilex.processFile(file);} function updateHiddenInputs() {if (!hiddenInputsContainer) return;const existingInputs = hiddenInputsContainer.querySelectorAll( ".existing-file-input" );const existingFilePaths = Array.from(existingInputs).map( (input) => input.value );const uploadedInputs = hiddenInputsContainer.querySelectorAll( ".uploaded-file-input" );uploadedInputs.forEach((input) => input.remove());const uniqueUploadedFiles = [...new Set(uploadedFiles)];uniqueUploadedFiles.forEach(function (filePath) {if (existingFilePaths.includes(filePath)) {return;} const input = document.createElement("input");input.type = "hidden";input.name = hiddenInputName;input.value = filePath;input.className = "uploaded-file-input";hiddenInputsContainer.appendChild(input);});} function updateFormState() {if (activeUploads > 0) {submitButtons.forEach((btn) => {btn.disabled = true;if (!btn.dataset.originalText) {btn.dataset.originalText = btn.textContent;} btn.innerHTML = '<svg xmlns="http:});} else {submitButtons.forEach((btn) => {btn.disabled = false;if (btn.dataset.originalText) {btn.textContent = btn.dataset.originalText;delete btn.dataset.originalText;}});}} function updateStatus() {if (!statusElement) return;const uploadingText = statusElement.querySelector(".uploading-text");const completedText = statusElement.querySelector(".completed-text");const errorText = statusElement.querySelector(".error-text");if (activeUploads > 0) {statusElement.style.display = "block";if (uploadingText) uploadingText.style.display = "inline";if (completedText) completedText.style.display = "none";if (errorText) errorText.style.display = "none";} else if (failedFiles.length > 0) {statusElement.style.display = "block";if (uploadingText) uploadingText.style.display = "none";if (completedText) completedText.style.display = "none";if (errorText) {errorText.style.display = "inline";const errorMessage = errorText.querySelector(".error-message");if (errorMessage) {errorMessage.textContent = failedFiles.length + " file(s) failed to upload";}}} else if (uploadedFiles.length > 0) {statusElement.style.display = "block";if (uploadingText) uploadingText.style.display = "none";if (completedText) completedText.style.display = "inline";if (errorText) errorText.style.display = "none";} else {statusElement.style.display = "none";}} if (parentForm) {parentForm.addEventListener("submit",function (e) {const isRequired = filexElement.classList.contains("required");if (isRequired && uploadedFiles.length === 0) {e.preventDefault();if (config.showErrorNotifications !== false) {showErrorMessage('Please upload at least one file before submitting',componentId,config.errorTimeout);} return false;} if (activeUploads > 0) {e.preventDefault();if (config.showErrorNotifications !== false) {showErrorMessage('Please wait for all files to finish uploading before submitting',componentId,config.errorTimeout);} return false;} if (failedFiles.length > 0) {e.preventDefault();const failedFileNames = failedFiles.map(f => f.name).join(',');const confirmMessage = `Some files failed to upload (${failedFileNames}). Do you want to continue without them?`;if (confirm(confirmMessage)) {return true;} else {if (config.showErrorNotifications !== false) {showErrorMessage('Please fix upload errors or remove failed files before submitting',componentId,config.errorTimeout);} return false;}}});} window[componentId + "_helpers"] = {getUploadedFiles: () => uploadedFiles,getFailedFiles: () => failedFiles,retryFailedUploads: () => {failedFiles.forEach((failed) => {retryUpload(failed.file);});},clearAll: () => {myFilex.removeAllFiles();uploadedFiles = [];failedFiles = [];updateHiddenInputs();updateStatus();},};});} function getFileIconSvg(extension) {const iconMap = {pdf: '<svg xmlns="http: doc: '<svg xmlns="http: docx: '<svg xmlns="http: xls: '<svg xmlns="http: xlsx: '<svg xmlns="http: ppt: '<svg xmlns="http: pptx: '<svg xmlns="http: txt: '<svg xmlns="http: zip: '<svg xmlns="http: jpg: '<svg xmlns="http: jpeg: '<svg xmlns="http: png: '<svg xmlns="http: mp3: '<svg xmlns="http: mp4: '<svg xmlns="http:};return ( iconMap[extension.toLowerCase()] || '<svg xmlns="http: );} function getCSRFToken() {const metaTag = document.querySelector('meta[name="csrf-token"]');return metaTag ? metaTag.getAttribute("content") : "";} if (document.readyState === "loading") {document.addEventListener("DOMContentLoaded",initializeFilex);} else {initializeFilex();} window.Filex = {initialize: initializeFilex,getFileIconSvg: getFileIconSvg,makeAjaxRequest: makeAjaxRequest,showError: showErrorMessage,showSuccess: showSuccessMessage,showWarning: showWarningMessage,showInfo: showInfoMessage,showNotification: showNotification,removeNotification: removeNotification,showErrorMessage: showErrorMessage,showSuccessMessage: showSuccessMessage};})(window,document);